/*
 * Authors: Haoyu Song and Dale Skrien
 * Latest change: Oct. 5, 2021
 *
 * In the grammar below, the variables are enclosed in angle brackets and
 * "::=" is used instead of "-->" to separate a variable from its rules.
 * The special character "|" is used to separate the rules for each variable
 * (but note that "||" is an operator).
 * EMPTY indicates a rule with an empty right hand side.
 * All other symbols in the rules are terminals.
 */
package proj8BogatyrevDimitrovWang.bantam.parser;


import proj8BogatyrevDimitrovWang.bantam.lexer.Scanner;
import proj8BogatyrevDimitrovWang.bantam.lexer.Token;
import proj8BogatyrevDimitrovWang.bantam.util.CompilationException;
import proj8BogatyrevDimitrovWang.bantam.util.Error;
import proj8BogatyrevDimitrovWang.bantam.util.ErrorHandler;
import proj8BogatyrevDimitrovWang.bantam.ast.*;

import java.io.IOException;
// TODO error token always the wrong type

import static proj8BogatyrevDimitrovWang.bantam.lexer.Token.Kind.*;


public class Parser
{
    // instance variables
    private Scanner scanner; // provides the tokens
    private Token currentToken; // the lookahead token
    private ErrorHandler errorHandler; // collects & organizes the error messages

    // constructor
    public Parser(ErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
    }

    /**
     * parse the given file and return the root node of the AST
     * @param filename The name of the Bantam Java file to be parsed
     * @return The Program node forming the root of the AST generated by the parser
     */
    public Program parse(String filename) { }


    /** helper function. Registers Parse error on 
     * error handler and throws compilation exception
     * @author Baron Wang
     * @param message error message to show
     * @throws CompilationException 
     */
    private void handleErr(String message) throws CompilationException{
        errorHandler.register(Error.Kind.PARSE_ERROR, message);
        throw new CompilationException(errorHandler);
    }
    
    // <Program> ::= <Class> | <Class> <Program>
    private Program parseProgram() {
        int position = currentToken.position;
        ClassList clist = new ClassList(position);

        while (currentToken.kind != EOF) {
            Class_ aClass = parseClass();
            clist.addElement(aClass);
        }

        return new Program(position, clist);
    }


    // <Class> ::= CLASS <Identifier> <ExtendsClause> { <MemberList> }
    // <ExtendsClause> ::= EXTENDS <Identifier> | EMPTY
    // <MemberList> ::= EMPTY | <Member> <MemberList>
    private Class_ parseClass() {
        int position = currentToken.position;
        boolean insideOfAClass = false;
        while (currentToken.kind != EOF) {
            if(!insideOfAClass) {
                if (currentToken.kind == Token.Kind.CLASS) {
                    // parse members

                }
            }
        }

    }


    //Fields and Methods
    // <Member> ::= <Field> | <Method>
    // <Method> ::= <Type> <Identifier> ( <Parameters> ) <BlockStmt>
    // <Field> ::= <Type> <Identifier> <InitialValue> ;
    // <InitialValue> ::= EMPTY | = <Expression>
    private Member parseMember() { }


    //-----------------------------------
    //Statements
    // <Stmt> ::= <WhileStmt> | <ReturnStmt> | <BreakStmt> | <VarDeclaration>
    //             | <ExpressionStmt> | <ForStmt> | <BlockStmt> | <IfStmt>
    private Stmt parseStatement() throws IOException {
            Stmt stmt;

            switch (currentToken.kind) {
                case IF:
                    stmt = parseIf();
                    break;
                case LCURLY:
                    stmt = parseBlock();
                    break;
                case VAR:
                    stmt = parseVarDeclaration();
                    break;
                case RETURN:
                    stmt = parseReturn();
                    break;
                case FOR:
                    stmt = parseFor();
                    break;
                case WHILE:
                    stmt = parseWhile();
                    break;
                case BREAK:
                    stmt = parseBreak();
                    break;
                default:
                    stmt = parseExpressionStmt();
            }

            return stmt;
    }


    // <WhileStmt> ::= WHILE ( <Expression> ) <Stmt>
    private Stmt parseWhile() { }


    // <ReturnStmt> ::= RETURN <Expression> ; | RETURN ;
    private Stmt parseReturn() throws IOException {
        /* inspired from the code shown in class on Tuesday */
         Expr expr = null;
        Token currentToken = scanner.scan();
         if (currentToken.kind != SEMICOLON){
             expr = parseExpression();
             if (currentToken.kind != SEMICOLON){
                 handleErr("Illegal return statement");
               }
        }
        currentToken = scanner.scan();
        return new ReturnStmt(currentToken.position, expr);
    }


    // <BreakStmt> ::= BREAK ;
    private Stmt parseBreak() { }


    // <ExpressionStmt> ::= <Expression> ;
    private ExprStmt parseExpressionStmt() { }


    // <VarDeclaration> ::= VAR <Id> = <Expression> ;
    // Every local variable must be initialized
    private Stmt parseVarDeclaration() throws IOException {
        int position = currentToken.position;
        String name = "";
        Expr expr;
        // get next token which should be an identifier
        currentToken = scanner.scan();
        if (currentToken.kind != IDENTIFIER){
            handleErr("Illegal var declaration statement: " +
                    "var must be initialized");
        }
        name = currentToken.getSpelling();
        currentToken = scanner.scan();
        if (currentToken.kind != ASSIGN){
            handleErr("Illegal var declaration statement: " +
                    "expecting an identifier");
        }
        currentToken = scanner.scan();
        expr = parseExpression();
        if (currentToken.kind != SEMICOLON){
                handleErr("Illegal var declaration " +
                        "statement: missing semicolon");
        }

        // always move the token forward by one
        currentToken = scanner.scan();
        return new DeclStmt(position, name, expr);
    }


    // <ForStmt> ::= FOR ( <Start> ; <Terminate> ; <Increment> ) <STMT>
    // <Start> ::=     EMPTY | <Expression>
    // <Terminate> ::= EMPTY | <Expression>
    // <Increment> ::= EMPTY | <Expression>
    private Stmt parseFor() { }


    // <BlockStmt> ::= { <Body> }
    // <Body> ::= EMPTY | <Stmt> <Body>
    private Stmt parseBlock() { }


    // <IfStmt> ::= IF ( <Expr> ) <Stmt> | IF ( <Expr> ) <Stmt> ELSE <Stmt>
    private Stmt parseIf() { }


    //-----------------------------------------
    // Expressions
    // Here we use different rules than the grammar on page 49
    // of the manual to handle the precedence of operations

    // <Expression> ::= <LogicalORExpr> <OptionalAssignment>
    // <OptionalAssignment> ::= EMPTY | = <Expression>
    private Expr parseExpression() { }


    // <LogicalOR> ::= <logicalAND> <LogicalORRest>
    // <LogicalORRest> ::= EMPTY |  || <LogicalAND> <LogicalORRest>
    private Expr parseOrExpr() throws IOException {
        int position = currentToken.position;
        Expr left;

        left = parseAndExpr();
        while (currentToken.spelling.equals("||")) {
            currentToken = scanner.scan();
            Expr right = parseAndExpr();
            left = new BinaryLogicOrExpr(position, left, right);
        }

        return left;
    }


    // <LogicalAND> ::= <ComparisonExpr> <LogicalANDRest>
    // <LogicalANDRest> ::= EMPTY |  && <ComparisonExpr> <LogicalANDRest>
    private Expr parseAndExpr() { }


    // <ComparisonExpr> ::= <RelationalExpr> <equalOrNotEqual> <RelationalExpr> |
    //                      <RelationalExpr>
    // <equalOrNotEqual> ::=  = | !=
    private Expr parseEqualityExpr() { }


    // <RelationalExpr> ::= <AddExpr> | <AddExpr> <ComparisonOp> <AddExpr>
    // <ComparisonOp> ::= < | > | <= | >=
    private Expr parseRelationalExpr() { }


    // <AddExpr>::Ôºù <MultExpr> <MoreMultExpr>
    // <MoreMultExpr> ::= EMPTY | + <MultExpr> <MoreMultExpr> | - <MultExpr> <MoreMultExpr>
    private Expr parseAddExpr() { }


    // <MultiExpr> ::= <NewCastOrUnary> <MoreNCU>
    // <MoreNCU> ::= * <NewCastOrUnary> <MoreNCU> |
    //               / <NewCastOrUnary> <MoreNCU> |
    //               % <NewCastOrUnary> <MoreNCU> |
    //               EMPTY
    private Expr parseMultExpr() { }

    // <NewCastOrUnary> ::= <NewExpression> | <CastExpression> | <UnaryPrefix>
    private Expr parseNewCastOrUnary() { }


    // <NewExpression> ::= NEW <Identifier> ( )
    private Expr parseNew() { }


    // <CastExpression> ::= CAST ( <Type> , <Expression> )
    private Expr parseCast() { }


    // <UnaryPrefix> ::= <PrefixOp> <UnaryPreFix> | <UnaryPostfix>
    // <PrefixOp> ::= - | ! | ++ | --
    private Expr parseUnaryPrefix() { }


    // <UnaryPostfix> ::= <Primary> <PostfixOp>
    // <PostfixOp> ::= ++ | -- | EMPTY
    private Expr parseUnaryPostfix() { }


    // <Primary> ::= ( <Expression> ) | <IntegerConst> | <BooleanConst> |
    //                              <StringConst> | <VarExpr>
    // <VarExpr> ::= <VarExprPrefix> <Identifier> <VarExprSuffix>
    // <VarExprPrefix> ::= SUPER . | THIS . | EMPTY
    // <VarExprSuffix> ::= ( <Arguments> ) | EMPTY
    private Expr parsePrimary() { }


    // <Arguments> ::= EMPTY | <Expression> <MoreArgs>
    // <MoreArgs>  ::= EMPTY | , <Expression> <MoreArgs>
    private ExprList parseArguments() { }


    // <Parameters> ::=  EMPTY | <Formal> <MoreFormals>
    // <MoreFormals> ::= EMPTY | , <Formal> <MoreFormals
    private FormalList parseParameters() { }


    // <Formal> ::= <Type> <Identifier>
    private Formal parseFormal() { }


    // <Type> ::= <Identifier>
    private String parseType() { }


    //----------------------------------------
    //Terminals

    private String parseOperator() { }


    private String parseIdentifier() { }


    private ConstStringExpr parseStringConst() {
        //...save the currentToken's string to a local variable...
        //...advance to the next token...
        //...return a new ConstStringExpr containing the string...
    }


    private ConstIntExpr parseIntConst() {  }


    private ConstBooleanExpr parseBoolean() { }

}

